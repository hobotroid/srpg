package sandy.materials {	import sandy.core.Scene3D;	import sandy.core.data.Polygon;	import sandy.core.scenegraph.Sprite2D;	import sandy.materials.attributes.MaterialAttributes;		import flash.display.Sprite;	import flash.utils.Dictionary;		/**	 * The Material class is the base class for all materials.	 * 	 * <p>Since the Material object is essentially a blank material, this class can be used	 * to apply attributes without any material to a 3D object.</p>	 *	 * @author		Thomas Pfeiffer - kiroukou	 * @version		3.1	 * @date 		26.07.2007	 *	 * @see Appearance	 */	public class Material	{		/**		 * The attributes of this material.		 */		public var attributes:MaterialAttributes;				/**		 * Specify if the material use the vertex normal information.		 * 		 * @default false		 */		public var useVertexNormal:Boolean = false;				/**		 * Specifies if the material can receive light and have light attributes applied to it.		 * Can be useful to rapidly disable light on the object when unneeded.		 */		public var lightingEnable:Boolean = false;				/**		 * Specifies if the material can automatically be disposed when unused		 * Default value is to true		 */		public var autoDispose:Boolean = true;				/**		 * Creates a material.		 *		 * <p>This constructor is never called directly - but by sub class constructors.</p>		 * @param p_oAttr	The attributes for this material.		 */		public function Material( p_oAttr:MaterialAttributes = null )		{			_filters 	= [];			_useLight 	= false;			_id = _ID_++;			attributes = (p_oAttr == null) ? new MaterialAttributes() : p_oAttr;			m_bModified = true;			m_oType = MaterialType.NONE;			m_nRefCounting = 0;			m_oPolygonMap = new Dictionary(true);		}				protected var m_oPolygonMap:Dictionary;		protected var m_nRefCounting:int;				/**		 * Method to call when you want to release the resources of that material (filters, attributes and lreferences to polygons)		 * Shape3D.DEFAULT_MATERIAL Material can't be disposed because might be used for later shape3D creations		 */		public function dispose():void		{			var l_oApp:Appearance;			var l_oPoly:Polygon;			for( var l_sLabel:String in m_oPolygonMap )			{				l_oPoly = Polygon(Polygon.POLYGON_MAP[l_sLabel]);				unlink(l_oPoly);				l_oApp = l_oPoly.appearance;				if( l_oApp.frontMaterial == this )					l_oApp.frontMaterial = null;				else if( l_oApp.backMaterial == this )					l_oApp.backMaterial = null;								delete m_oPolygonMap[l_sLabel];			}			attributes = null;			_filters = null;		}				/**		 * The unique id of this material.		 */		public function get id():Number		{				return _id;		}				/**		 * Calls begin method of the MaterialAttributes associated with this material.		 *		 * @param p_oScene	The scene.		 *		 * @see sandy.materials.attributes.MaterialAttributes#begin()		 */		public function begin( p_oScene:Scene3D ):void		{			if (lastBegin != p_oScene.frameCount) {				if( attributes )					attributes.begin( p_oScene );				lastBegin = p_oScene.frameCount;			}		}		private var lastBegin:int = 0;				/**		 * Calls finish method of the MaterialAttributes associated with this material.		 *		 * @param p_oScene	The scene.		 *		 * @see sandy.materials.attributes.MaterialAttributes#finish()		 */		public function finish( p_oScene:Scene3D ):void		{			if (lastFinish != p_oScene.frameCount) {				if( attributes )					attributes.finish(p_oScene );				lastFinish = p_oScene.frameCount;			}			// --			m_bModified = false;		}		private var lastFinish:int = 0;				/**		 * Renders the polygon dress in this material.		 *		 * <p>Implemented by sub classes.</p>		 *		 * @see sandy.core.Scene3D		 * @see sandy.core.data.Polygon		 */		public function renderPolygon( p_oScene:Scene3D, p_oPolygon:Polygon, p_mcContainer:Sprite ):void		{			if( attributes )				attributes.draw( p_mcContainer.graphics, p_oPolygon, this, p_oScene );			// --			if( _filters && _filters.length > 0 )				p_mcContainer.filters = _filters;		}					/**		 * Renders the sprite dress in this material.		 *		 * <p>Basically only needed to apply attributes to sprites</p>		 *		 * @see sandy.core.scenegraph.Sprite2D		 * @see sandy.core.Scene3D		 */		public function renderSprite( p_oSprite:Sprite2D, p_oMaterial:Material, p_oScene:Scene3D ):void		{			if( attributes )			{				attributes.drawOnSprite( p_oSprite, p_oMaterial, p_oScene );			}			// --			if( _filters && _filters.length > 0 )				p_oSprite.content.filters = _filters;		}		/**		 * Calls init method of the MaterialAttributes associated with this material.		 *		 * @see sandy.materials.attributes.MaterialAttributes#init()		 */		public function init( p_oPolygon:Polygon ):void		{			if( !m_oPolygonMap[p_oPolygon.id] )			{				m_oPolygonMap[p_oPolygon.id] = 1;				m_nRefCounting ++;				if( attributes )					attributes.init( p_oPolygon );			}			else			{				m_oPolygonMap[p_oPolygon.id]++;			}		}			/**		 * Calls unlink method of the MaterialAttributes associated with this material.		 *		 * @see sandy.materials.attributes.MaterialAttributes#unlink()		 */		public function unlink( p_oPolygon:Polygon ):void		{			if( m_oPolygonMap[p_oPolygon.id] )			{				m_oPolygonMap[p_oPolygon.id] --;				if( m_oPolygonMap[p_oPolygon.id] == 0 )				{					delete m_oPolygonMap[p_oPolygon.id];					m_nRefCounting --;					if( attributes )						attributes.unlink( p_oPolygon );				}			}			//			if( autoDispose && m_nRefCounting <= 0 )			{				dispose();			}		}				/**		 * Unlink all the non used polygons		 */		public function unlinkAll():Array		{			var l_aUnlinked:Array = [];			var l_oApp:Appearance;			var l_oPoly:Polygon;			for( var l_sLabel:String in m_oPolygonMap )			{				l_oPoly = Polygon(Polygon.POLYGON_MAP[l_sLabel]);				l_oApp = l_oPoly.appearance;				if( l_oApp.frontMaterial == this || l_oApp.backMaterial == this )				{					unlink(l_oPoly);					l_aUnlinked.push( l_oPoly );				}			}			return l_aUnlinked;		}				/**		 * The material type of this material.		 * 		 * @default MaterialType.NONE		 *		 * @see MaterialType		 */		public function get type():MaterialType		{ 			return m_oType; 		}				/**		 * @private		 */		public function set filters( a:Array ):void		{ 			if( a != _filters )			{				_filters = a;				m_bModified = true;			}		}				/**		 * Contains specific material flags.		 */		public function get flags():uint		{			var l_nFlags:uint = m_nFlags;			if( attributes ) 				l_nFlags |= attributes.flags;			return l_nFlags;		}				/**		 * The array of filters for this material.		 * 		 * <p>You use this property to add an array of filters you want to apply to this material<br>		 * To remove the filters, just assign an empty array.</p>		 */		public function get filters():Array		{ 			return _filters; 		}				/**		 * The modified state of this material.		 *		 * <p>true if this material or its line attributes were modified since last rendered, false otherwise.</p> 		 */		public function get modified():Boolean		{			return m_bModified;// && ((lineAttributes) ? lineAttributes.modified : true));		}						/**		 * The repeat property.		 * 		 * This affects the way textured materials are mapped for U or V out of 0-1 range.		 */		public var repeat:Boolean = true;				//////////////////		// PROPERTIES		//////////////////		/**		 * DO NOT TOUCH THIS PROPERTY UNLESS YOU PERFECTLY KNOW WHAT YOU ARE DOING.		 * this flag property contains the specific material flags.		 *		 * @private		 */		protected var m_nFlags:uint = 0;				/**		 * @private		 */		protected var m_bModified:Boolean;				/**		 * @private		 */		protected var _useLight : Boolean = false;				/**		 * @private		 */		protected var m_oType:MaterialType;						private var _filters:Array;		private var _id:Number;		private static var _ID_:Number = 0;				//private static var create:Boolean;	}}